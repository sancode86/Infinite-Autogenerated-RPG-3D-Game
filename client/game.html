<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="css/styles.css" />

    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css"
    />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta2/css/all.min.css"
    />
    <title>Infinite RPG</title>
  </head>
  <body>
    <div class="statsDiv" id="statsDiv"></div>
    <div class="sidebar">
      <div class="hora" id="clock"></div>
      <a href="#" onclick="preferencesOpen()"
        ><i class="fa-solid fa-user"></i>
      </a>
    </div>
    <div
      id="optionsMenu"
      class="optionsMenu animate__animated animate__fadeIn"
      style="display: none"
    >
      <div class="center"></div>
      <br />
      <div class="center">
        <button class="botonSave" onclick="preferencesClose()">Close</button>
      </div>
    </div>
  </body>
</html>
<script src="js/menuDragInGame.js"></script>
<script src="js/optionsMenu.js"></script>

<script type="module">
  import * as THREE from "https://cdn.skypack.dev/three@0.128.0/build/three.module.js";
  import { OrbitControls } from "https://cdn.skypack.dev/three@0.128.0/examples/jsm/controls/OrbitControls.js";
  import { GLTFLoader } from "https://cdn.skypack.dev/three@0.128.0/examples/jsm/loaders/GLTFLoader.js";
  import { OBJLoader } from "https://cdn.skypack.dev/three@0.128.0/examples/jsm/loaders/OBJLoader.js";

  var arraySolidos = [];
  var gameTime = 1111104000000;
  var stats = new Stats();
  var statsDiv = document.getElementById("statsDiv");
  var posicionActualJugador = new THREE.Vector3(0, 0, 0);
  stats.showPanel(0);
  statsDiv.appendChild(stats.domElement);

  import { KeyDisplay } from "./utils/utils.js";
  import { CharacterControls } from "./utils/characterControls.js";

  // SCENE
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0xa8def0);

  // CAMERA
  const camera = new THREE.PerspectiveCamera(
    45,
    window.innerWidth / window.innerHeight,
    0.1,
    1000
  );
  camera.position.y = 5;
  camera.position.z = 5;
  camera.position.x = 0;

  // RENDERER
  const renderer = new THREE.WebGLRenderer({ antialias: false });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.shadowMap.enabled = true;

  // CONTROLS
  const orbitControls = new OrbitControls(camera, renderer.domElement);
  orbitControls.enableDamping = true;
  orbitControls.minDistance = 1;
  orbitControls.maxDistance = 15;
  orbitControls.enablePan = false;
  orbitControls.maxPolarAngle = Math.PI / 2 - 0.05;
  orbitControls.update();

  var jugador;
  // jugador WITH ANIMATIONS
  var characterControls;
  new GLTFLoader().load("models/Soldier.glb", function (gltf) {
    jugador = gltf.scene;
    jugador.traverse(function (object) {
      if (object.isMesh) object.castShadow = true;
    });
    jugador.userData.name = "jugador";
    jugador.position.set(0, 0, 0);
    var jugadorGeometry = new THREE.BoxGeometry(1, 3, 1);
    jugador.geometry = jugadorGeometry;
    scene.add(jugador);

    const gltfAnimations = gltf.animations;
    const mixer = new THREE.AnimationMixer(jugador);
    const animationsMap = new Map();
    gltfAnimations
      .filter((a) => a.name != "TPose")
      .forEach((a) => {
        animationsMap.set(a.name, mixer.clipAction(a));
      });

    characterControls = new CharacterControls(
      jugador,
      mixer,
      animationsMap,
      orbitControls,
      camera,
      "Idle"
    );
  });

  new GLTFLoader().load("models/horse.glb", function (gltf) {
    const test123 = gltf.scene;
    test123.traverse(function (object) {
      if (object.isMesh) object.castShadow = true;
    });
    var geo = new THREE.BoxGeometry(3, 3, 3);
    test123.geometry = geo;
    test123.position.x = 9;
    test123.position.y = 0;
    // test123.rotation.y = Math.PI / 2;
    test123.scale.set(1, 1, 1);
    scene.add(test123);
console.log(test123)
    arraySolidos.push(test123)
  });
  new GLTFLoader().load("models/columna.glb", function (gltf) {
    const test = gltf.scene;
    test.traverse(function (object) {
      if (object.isMesh) object.castShadow = true;
    });
    var geo = new THREE.BoxGeometry(1.5, 3, 1.5);
    test.geometry = geo;
    test.position.x = 5;
    test.position.y = 0;
    // test.rotation.y = Math.PI / 2;
    test.scale.set(1, 1, 1);
    scene.add(test);
    console.log(test)
   arraySolidos.push(test)
  });

  //   new GLTFLoader().load("models/test.gltf", function (gltf) {
  //      const test = gltf.scene;
  //      test.traverse(function (object) {
  //        if (object.isMesh) object.castShadow = true;
  //      });
  //      test.position.x = 5
  //      test.position.y = 0
  //      test.scale.set(1.7, 1.7, 1.7);
  //     scene.add(test);

  //  });

  // new GLTFLoader().load("jugadors/dos.glb", function (gltf) {
  //   const jugador = gltf.scene;
  //   jugador.traverse(function (object) {
  //     if (object.isMesh) object.castShadow = true;
  //   });
  //   jugador.castShadow = true;
  //   jugador.receiveShadow = true;
  //   jugador.position.x = 10;
  //   jugador.position.y = -0.4;

  //   jugador.scale.set(1, 1, 1);
  //   scene.add(jugador);
  // });

  //raycaster
  const raycaster = new THREE.Raycaster();
  const clicMouse = new THREE.Vector2();
  const moveMouse = new THREE.Vector2();

  var draggable;

  window.addEventListener("click", (event) => {
  
    if (draggable) {
      console.log("soltando");
      document.body.style.cursor = "default";
      draggable = null;
      return;
    }

    clicMouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    clicMouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
    raycaster.setFromCamera(clicMouse, camera);
    const found = raycaster.intersectObjects(scene.children);

    if (found.length > 0 && found[0].object.userData.draggable) {
      draggable = found[0].object;
      console.log(draggable.userData.name);
      document.body.style.cursor = "grab";
    }
  });

  window.addEventListener("mousemove", (event) => {
    moveMouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    moveMouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

    raycaster.setFromCamera(moveMouse, camera);
    const found = raycaster.intersectObjects(scene.children);

    if (draggable == null) {
      document.body.style.cursor = "default";
    }
    if (found[0].object.userData.draggable && draggable == null) {
      document.body.style.cursor = "pointer";
    }
  });

  function draggObj() {
    if (draggable != null) {
      raycaster.setFromCamera(moveMouse, camera);
      const found = raycaster.intersectObjects(scene.children);
      if (found.length > 0) {
        for (let o of found) {
          if (
            !o.object.userData.ground &&
            o.object.userData.pared != true &&
            o.object.userData.nombre != "universo"
          ) {
            draggable.position.x = o.point.x;
            draggable.position.z = o.point.z;
          }
        }
      }
    }
  }
  function checkearSiSeTocan(a, d) {
    let b1 = a.position.y - a.geometry.parameters.height / 2;
    let t1 = a.position.y + a.geometry.parameters.height / 2;
    let r1 = a.position.x + a.geometry.parameters.width / 2;
    let l1 = a.position.x - a.geometry.parameters.width / 2;
    let f1 = a.position.z - a.geometry.parameters.depth / 2;
    let B1 = a.position.z + a.geometry.parameters.depth / 2;

    let b2 = d.position.y - d.geometry.parameters.height / 2;
    let t2 = d.position.y + d.geometry.parameters.height / 2;
    let r2 = d.position.x + d.geometry.parameters.width / 2;
    let l2 = d.position.x - d.geometry.parameters.width / 2;
    let f2 = d.position.z - d.geometry.parameters.depth / 2;
    let B2 = d.position.z + d.geometry.parameters.depth / 2;

    if (t1 < b2 || r1 < l2 || b1 > t2 || l1 > r2 || f1 > B2 || B1 < f2) {
      return false;
    }

    return true;
  }
  function checkearSiSeTocaJugador(a, d) {
    let r1 = a.position.x + a.geometry.parameters.width / 2;
    let l1 = a.position.x - a.geometry.parameters.width / 2;
    let f1 = a.position.z - a.geometry.parameters.depth / 2;
    let B1 = a.position.z + a.geometry.parameters.depth / 2;

    let r2 = d.position.x + d.geometry.parameters.width / 2;
    let l2 = d.position.x - d.geometry.parameters.width / 2;
    let f2 = d.position.z - d.geometry.parameters.depth / 2;
    let B2 = d.position.z + d.geometry.parameters.depth / 2;

    if (r1 < l2 || l1 > r2 || f1 > B2 || B1 < f2) {
      return false;
    } else {
      if (a.position.x > d.position.x) {
        // console.log("derecha");
        // console.log(a.position.x);
        return "derecha";
      }

      if (a.position.z < d.position.z) {
        // console.log("arriba");
        // console.log(a.position.z);
        return "arriba";
      }
      if (a.position.z > d.position.z) {
        // console.log("abajo");
        // console.log(a.position.z);
        return "abajo";
      }

      if (a.position.x < d.position.x) {
        // console.log("izquierda");
        // console.log(a.position.x);
        return "izquierda";
      }
    }
  }

  var tamañoCuarto = 50;

  var spawnArea = tamañoCuarto / 2;
  var cantidadCajas = 10;

  crearCajas();
  crearParedes(4);

  function crearCajas() {
    for (let j = 0; j < cantidadCajas; j++) {
      // crear una caja
      const geoBox = new THREE.BoxGeometry(1, 1, 1);
      var r1 = Math.floor(Math.random() * (80 - 10)) + 10;
      var r2 = Math.floor(Math.random() * (80 - 10)) + 10;
      var r3 = Math.floor(Math.random() * (80 - 10)) + 10;
      var aparienciaColor = "0x" + r1 + r2 + r3;
      const matBox = new THREE.MeshPhongMaterial({
        color: parseInt(aparienciaColor),
      });
      const box = new THREE.Mesh(geoBox, matBox);
      box.castShadow = true;
      box.receiveShadow = true;
      box.userData.draggable = true;
      box.userData.name = "Caja" + j;
      box.position.x =
        Math.floor(Math.random() * (spawnArea - -spawnArea)) + -spawnArea;
      box.position.y = 0.5;
      box.position.z =
        Math.floor(Math.random() * (spawnArea - -spawnArea)) + -spawnArea;
      scene.add(box);
      arraySolidos.push(box);
    }
  }

  function crearParedes(cantidadParedes) {
    var cantidad = cantidadParedes;

    // crear una pared
    const geoBox = new THREE.BoxGeometry(tamañoCuarto, 10, 1);
    var aparienciaColor = "0x101010";
    const matPared = new THREE.MeshPhongMaterial({
      color: parseInt(aparienciaColor),
    });
    const pared = new THREE.Mesh(geoBox, matPared);
    pared.castShadow = true;
    pared.receiveShadow = true;
    pared.userData.name = "Pared";
    pared.position.x = 0;
    pared.position.y = 0;
    pared.position.z = tamañoCuarto / 2;
    scene.add(pared);
    arraySolidos.push(pared);
    camera.updateProjectionMatrix();
    const geoBox2 = new THREE.BoxGeometry(1, 10, tamañoCuarto);
    const pared2 = new THREE.Mesh(geoBox2, matPared);
    pared2.castShadow = true;
    pared2.receiveShadow = true;
    pared2.userData.name = "Pared2";
    pared2.position.x = tamañoCuarto / 2;
    pared2.position.y = 0;
    pared2.position.z = 0;
    scene.add(pared2);
    arraySolidos.push(pared2);
    camera.updateProjectionMatrix();
    const geoBox3 = new THREE.BoxGeometry(1, 10, tamañoCuarto);
    const pared3 = new THREE.Mesh(geoBox3, matPared);
    pared3.castShadow = true;
    pared3.receiveShadow = true;
    pared3.userData.name = "Pared3";
    pared3.position.x = -tamañoCuarto / 2;
    pared3.position.y = 0;
    pared3.position.z = 0;
    scene.add(pared3);
    arraySolidos.push(pared3);
    camera.updateProjectionMatrix();
    const geoBox4 = new THREE.BoxGeometry(tamañoCuarto, 10, 1);
    const pared4 = new THREE.Mesh(geoBox4, matPared);
    pared4.castShadow = true;
    pared4.receiveShadow = true;
    pared4.userData.name = "Pared4";
    pared4.position.x = 0;
    pared4.position.y = 0;
    pared4.position.z = -tamañoCuarto / 2;
    scene.add(pared4);
    arraySolidos.push(pared4);

    pared.userData.ground = false;
    pared2.userData.ground = false;
    pared3.userData.ground = false;
    pared4.userData.ground = false;

    pared.userData.pared = true;
    pared2.userData.pared = true;
    pared3.userData.pared = true;
    pared4.userData.pared = true;

    camera.updateProjectionMatrix();
  }

  // CONTROL KEYS
  const keysPressed = {};
  const keyDisplayQueue = new KeyDisplay();
  document.addEventListener(
    "keydown",
    (event) => {
      keyDisplayQueue.down(event.key);
      if (event.shiftKey && characterControls) {
        characterControls.switchRunToggle();
      } else {
        keysPressed[event.key.toLowerCase()] = true;
      }
    },
    false
  );
  document.addEventListener(
    "keyup",
    (event) => {
      keyDisplayQueue.up(event.key);
      keysPressed[event.key.toLowerCase()] = false;
    },
    false
  );

  const clock = new THREE.Clock();

  // RESIZE HANDLER
  function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  }
  window.addEventListener("resize", onWindowResize);

  generateFloorBasic();

  function generateFloorBasic() {
    const geoPiso = new THREE.PlaneGeometry(
      tamañoCuarto,
      tamañoCuarto,
      tamañoCuarto
    );
    const matPiso = new THREE.MeshPhongMaterial({ color: 0x606060 });
    const pisoSimple = new THREE.Mesh(geoPiso, matPiso);
    pisoSimple.castShadow = true;
    pisoSimple.receiveShadow = true;
    pisoSimple.rotation.x = -Math.PI / 2;
    pisoSimple.userData.ground = true;
    scene.add(pisoSimple);
  }

  scene.add(new THREE.AmbientLight(0xffffff, 0.7));

  const dirLight = new THREE.DirectionalLight(0xffffff, 1);
  dirLight.position.set(-50, 50, 0);
  dirLight.castShadow = true;
  dirLight.shadow.camera.top = 100;
  dirLight.shadow.camera.bottom = -100;
  dirLight.shadow.camera.left = -100;
  dirLight.shadow.camera.right = 100;
  dirLight.shadow.camera.near = 0.1;
  dirLight.shadow.camera.far = 100;
  dirLight.shadow.mapSize.width = 4096;
  dirLight.shadow.mapSize.height = 4096;
  scene.add(dirLight);

  var orbitaDelSol = 200;
  var velMovSol = -0.00000015;

  // ANIMATE
  function animate() {
    stats.begin();
    draggObj();

    horaActual();

    let mixerUpdateDelta = clock.getDelta();
    if (characterControls) {
      characterControls.update(mixerUpdateDelta, keysPressed);
    }

    orbitControls.update();
    renderer.render(scene, camera);
    requestAnimationFrame(animate);
    chequearChoque();
    stats.end();
  }

  animate();

  document.body.appendChild(renderer.domElement);

  function horaActual() {
    var speed = 10000;
    let clockDiv = document.querySelector("#clock");
    let sec = Math.floor(gameTime / 1000) % 60;
    let min = Math.floor(gameTime / 60000) % 60;
    let hour = Math.floor(gameTime / 3600000) % 24;
    clockDiv.textContent = `${hour}:${min}`.replace(/\b\d\b/g, "0$&");
    gameTime += speed;
  }

  crearSkybox();
  function crearSkybox() {
    let materialArray = [];
    let texture_up = new THREE.TextureLoader().load("img/skybox/up.jpg");
    let texture_rt = new THREE.TextureLoader().load("img/skybox/rt.jpg");
    let texture_lf = new THREE.TextureLoader().load("img/skybox/lf.jpg");
    let texture_ft = new THREE.TextureLoader().load("img/skybox/ft.jpg");
    let texture_dn = new THREE.TextureLoader().load("img/skybox/dn.jpg");
    let texture_bk = new THREE.TextureLoader().load("img/skybox/bk.jpg");
    materialArray.push(new THREE.MeshBasicMaterial({ map: texture_ft }));
    materialArray.push(new THREE.MeshBasicMaterial({ map: texture_bk }));
    materialArray.push(new THREE.MeshBasicMaterial({ map: texture_up }));
    materialArray.push(new THREE.MeshBasicMaterial({ map: texture_dn }));
    materialArray.push(new THREE.MeshBasicMaterial({ map: texture_rt }));
    materialArray.push(new THREE.MeshBasicMaterial({ map: texture_lf }));
    for (let i = 0; i < 6; i++) materialArray[i].side = THREE.BackSide;
    var tamaño = tamañoCuarto * 3;
    let skyboxGeo = new THREE.BoxGeometry(tamaño, tamaño, tamaño);
    var skybox = new THREE.Mesh(skyboxGeo, materialArray);
    skybox.castShadow = true;
    skybox.receiveShadow = true;

    skybox.userData = {
      nombre: "universo",
      tipo: "infinito",
    };
    scene.add(skybox);
  }

  function chequearChoque() {
    if (jugador?.position != undefined) {
      for (let index = 0; index < arraySolidos.length; index++) {
        var resultado = checkearSiSeTocaJugador(jugador, arraySolidos[index]);

        if (resultado == "derecha") {
          const frenar = new THREE.Vector3(0.1, 0, 0);
          jugador.position.add(frenar);
        }
        if (resultado == "izquierda") {
          const frenar = new THREE.Vector3(-0.1, 0, 0);
          jugador.position.add(frenar);
        }
        if (resultado == "arriba") {
          const frenar = new THREE.Vector3(0, 0, -0.1);
          jugador.position.add(frenar);
        }
        if (resultado == "abajo") {
          const frenar = new THREE.Vector3(0, 0, 0.1);
          jugador.position.add(frenar);
        }
      }
    }
  }
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/stats.js/r16/Stats.min.js"></script>
