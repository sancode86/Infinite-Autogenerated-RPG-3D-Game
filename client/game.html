<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="css/styles.css" />

    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css"
    />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta2/css/all.min.css"
    />
    <title>Document</title>
  </head>
  <body>
    <div class="statsDiv" id="statsDiv"></div>
    <div class="sidebar">
      <div class="hora" id="clock"></div>
      <a href="#" onclick="preferencesOpen()"
        ><i class="fa-solid fa-user"></i>
      </a>
    </div>
    <div
      id="optionsMenu"
      class="optionsMenu animate__animated animate__fadeIn"
      style="display: none"
    >
      <div class="center"></div>
      <br />
      <div class="center">
        <button class="botonSave" onclick="preferencesClose()">Close</button>
      </div>
    </div>
  </body>
</html>
<script src="js/menuDragInGame.js"></script>
<script src="js/optionsMenu.js"></script>

<script type="module">
  import * as THREE from "https://cdn.skypack.dev/three@0.128.0/build/three.module.js";
  import { OrbitControls } from "https://cdn.skypack.dev/three@0.128.0/examples/jsm/controls/OrbitControls.js";
  import { GLTFLoader } from "https://cdn.skypack.dev/three@0.128.0/examples/jsm/loaders/GLTFLoader.js";
  import { OBJLoader } from "https://cdn.skypack.dev/three@0.128.0/examples/jsm/loaders/OBJLoader.js";

  var tamañoCuarto = 50;
  var gameTime = 1111104000000;
  var stats = new Stats();
  var statsDiv = document.getElementById("statsDiv");

  stats.showPanel(0);
  statsDiv.appendChild(stats.domElement);

  import { KeyDisplay } from "./utils/utils.js";
  import { CharacterControls } from "./utils/characterControls.js";

  // SCENE
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0xa8def0);

  // CAMERA
  const camera = new THREE.PerspectiveCamera(
    45,
    window.innerWidth / window.innerHeight,
    0.1,
    1000
  );
  camera.position.y = 5;
  camera.position.z = 5;
  camera.position.x = 0;

  // RENDERER
  const renderer = new THREE.WebGLRenderer({ antialias: false });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.shadowMap.enabled = true;

  // CONTROLS
  const orbitControls = new OrbitControls(camera, renderer.domElement);
  orbitControls.enableDamping = true;
  orbitControls.minDistance = 1;
  orbitControls.maxDistance = 15;
  orbitControls.enablePan = false;
  orbitControls.maxPolarAngle = Math.PI / 2 - 0.05;
  orbitControls.update();

  var model;
  // MODEL WITH ANIMATIONS
  var characterControls;
  new GLTFLoader().load("models/Soldier.glb", function (gltf) {
    model = gltf.scene;
    model.traverse(function (object) {
      if (object.isMesh) object.castShadow = true;
    });
    model.userData.name = "jugador";
    // model.position.set(1,1,1)
    scene.add(model);

    const gltfAnimations = gltf.animations;
    const mixer = new THREE.AnimationMixer(model);
    const animationsMap = new Map();
    gltfAnimations
      .filter((a) => a.name != "TPose")
      .forEach((a) => {
        animationsMap.set(a.name, mixer.clipAction(a));
      });

    characterControls = new CharacterControls(
      model,
      mixer,
      animationsMap,
      orbitControls,
      camera,
      "Idle"
    );
  });

  //  new GLTFLoader().load("models/cc.glb", function (gltf) {
  //     const model = gltf.scene;
  //     model.traverse(function (object) {
  //       if (object.isMesh) object.castShadow = true;
  //     });
  //     model.position.x = 18
  //     model.position.y = 0
  //     model.scale.set(1, 1, 1);
  //     scene.add(model);

  //   });

  // new GLTFLoader().load("models/dos.glb", function (gltf) {
  //   const model = gltf.scene;
  //   model.traverse(function (object) {
  //     if (object.isMesh) object.castShadow = true;
  //   });
  //   model.castShadow = true;
  //   model.receiveShadow = true;
  //   model.position.x = 10;
  //   model.position.y = -0.4;

  //   model.scale.set(1, 1, 1);
  //   scene.add(model);
  // });

  //raycaster
  const raycaster = new THREE.Raycaster();
  const clicMouse = new THREE.Vector2();
  const moveMouse = new THREE.Vector2();

  var draggable;

  window.addEventListener("click", (event) => {
    if (draggable) {
      console.log("soltando");
      document.body.style.cursor = "default";
      draggable = null;
      return;
    }

    clicMouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    clicMouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
    raycaster.setFromCamera(clicMouse, camera);
    const found = raycaster.intersectObjects(scene.children);

    if (found.length > 0 && found[0].object.userData.draggable) {
      draggable = found[0].object;
      console.log(draggable.userData.name);
      document.body.style.cursor = "grab";
    }
  });

  window.addEventListener("mousemove", (event) => {
    moveMouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    moveMouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

    raycaster.setFromCamera(moveMouse, camera);
    const found = raycaster.intersectObjects(scene.children);

    if (draggable == null) {
      document.body.style.cursor = "default";
    }
    if (found[0].object.userData.draggable && draggable == null) {
      document.body.style.cursor = "pointer";
    }
  });

  function draggObj() {
    if (draggable != null) {
      // chequearChoque()
      raycaster.setFromCamera(moveMouse, camera);
      const found = raycaster.intersectObjects(scene.children);
      if (found.length > 0) {
        for (let o of found) {
          if (!o.object.userData.ground) {
            draggable.position.x = o.point.x;
            draggable.position.z = o.point.z;
          }
        }
      }
    }
  }
  function checkearSiSeTocan(a, d) {
    let b1 = a.position.y - a.geometry.parameters.height / 2;
    let t1 = a.position.y + a.geometry.parameters.height / 2;
    let r1 = a.position.x + a.geometry.parameters.width / 2;
    let l1 = a.position.x - a.geometry.parameters.width / 2;
    let f1 = a.position.z - a.geometry.parameters.depth / 2;
    let B1 = a.position.z + a.geometry.parameters.depth / 2;
    let b2 = d.position.y - d.geometry.parameters.height / 2;
    let t2 = d.position.y + d.geometry.parameters.height / 2;
    let r2 = d.position.x + d.geometry.parameters.width / 2;
    let l2 = d.position.x - d.geometry.parameters.width / 2;
    let f2 = d.position.z - d.geometry.parameters.depth / 2;
    let B2 = d.position.z + d.geometry.parameters.depth / 2;
    if (t1 < b2 || r1 < l2 || b1 > t2 || l1 > r2 || f1 > B2 || B1 < f2) {
      return false;
    }
    return true;
  }






















  var spawnArea = tamañoCuarto / 2;
  var cantidadCajas = 10;
  
  crearCajas();
  crearParedes(4);

  function crearCajas() {
    for (let j = 0; j < cantidadCajas; j++) {
      // crear una caja
      const geoBox = new THREE.BoxGeometry(1, 1, 1);
      var r1 = Math.floor(Math.random() * (80 - 10)) + 10;
      var r2 = Math.floor(Math.random() * (80 - 10)) + 10;
      var r3 = Math.floor(Math.random() * (80 - 10)) + 10;
      var aparienciaColor = "0x" + r1 + r2 + r3;
      const matBox = new THREE.MeshPhongMaterial({ color: parseInt(aparienciaColor) });
      const box = new THREE.Mesh(geoBox, matBox);
      box.castShadow = true;
      box.receiveShadow = true;
      box.userData.draggable = true;
      box.userData.name = "Caja" + j;
      box.position.x =
        Math.floor(Math.random() * (spawnArea - -spawnArea)) + -spawnArea;
      box.position.y = 0.5;
      box.position.z =
        Math.floor(Math.random() * (spawnArea - -spawnArea)) + -spawnArea;
      scene.add(box);
    }
  }

  
  function crearParedes(cantidadParedes) {
    var cantidad = cantidadParedes;
    for (let j = 0; j < cantidad; j++) {
      // crear una pared
      const geoBox = new THREE.BoxGeometry(1, 10, 1);    
      var aparienciaColor = "0x101010";
      const matBox = new THREE.MeshPhongMaterial({ color: parseInt(aparienciaColor) });
      const pared = new THREE.Mesh(geoBox, matBox);
      pared.castShadow = true;
      pared.receiveShadow = true;     
      pared.userData.name = "Pared" + j;
      pared.position.x =  Math.floor(Math.random() * (spawnArea - -spawnArea)) + -spawnArea;
      pared.position.y = 0.5;
      pared.position.z =  Math.floor(Math.random() * (spawnArea - -spawnArea)) + -spawnArea;
      scene.add(pared);
    }
  }

  // CONTROL KEYS
  const keysPressed = {};
  const keyDisplayQueue = new KeyDisplay();
  document.addEventListener(
    "keydown",
    (event) => {
      keyDisplayQueue.down(event.key);
      if (event.shiftKey && characterControls) {
        characterControls.switchRunToggle();
      } else {
        keysPressed[event.key.toLowerCase()] = true;
      }
    },
    false
  );
  document.addEventListener(
    "keyup",
    (event) => {
      keyDisplayQueue.up(event.key);
      keysPressed[event.key.toLowerCase()] = false;
    },
    false
  );

  const clock = new THREE.Clock();

  // RESIZE HANDLER
  function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    keyDisplayQueue.updatePosition();
  }
  window.addEventListener("resize", onWindowResize);

  generateFloorBasic();

  function generateFloorBasic() {
    const geoPiso = new THREE.PlaneGeometry(
      tamañoCuarto,
      tamañoCuarto,
      tamañoCuarto
    );
    const matPiso = new THREE.MeshPhongMaterial({ color: 0x606060 });
    const pisoSimple = new THREE.Mesh(geoPiso, matPiso);
    pisoSimple.castShadow = true;
    pisoSimple.receiveShadow = true;
    pisoSimple.rotation.x = -Math.PI / 2;
    pisoSimple.userData.ground = true;
    scene.add(pisoSimple);
  }

  scene.add(new THREE.AmbientLight(0xffffff, 0.7));

  const dirLight = new THREE.DirectionalLight(0xffffff, 1);
  dirLight.position.set(-50, 50, 0);
  dirLight.castShadow = true;
  dirLight.shadow.camera.top = 100;
  dirLight.shadow.camera.bottom = -100;
  dirLight.shadow.camera.left = -100;
  dirLight.shadow.camera.right = 100;
  dirLight.shadow.camera.near = 0.1;
  dirLight.shadow.camera.far = 100;
  dirLight.shadow.mapSize.width = 4096;
  dirLight.shadow.mapSize.height = 4096;
  scene.add(dirLight);

  var orbitaDelSol = 200;
  var velMovSol = -0.00000015;

  // ANIMATE
  function animate() {
    stats.begin();
    draggObj();
    // chequearChoque();
    horaActual();

    let mixerUpdateDelta = clock.getDelta();
    if (characterControls) {
      characterControls.update(mixerUpdateDelta, keysPressed);
    }

    orbitControls.update();
    renderer.render(scene, camera);
    requestAnimationFrame(animate);
    stats.end();
  }

  animate();

  document.body.appendChild(renderer.domElement);

  function horaActual() {
    var speed = 10000;
    let clockDiv = document.querySelector("#clock");
    let sec = Math.floor(gameTime / 1000) % 60;
    let min = Math.floor(gameTime / 60000) % 60;
    let hour = Math.floor(gameTime / 3600000) % 24;
    clockDiv.textContent = `${hour}:${min}`.replace(/\b\d\b/g, "0$&");
    gameTime += speed;
  }
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/stats.js/r16/Stats.min.js"></script>
